From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sat, 24 Oct 2020 23:01:02 +0800
Subject: [PATCH] Hardware acceleration

This patch integrates Yatopia-Hwaccel into the server

diff --git a/pom.xml b/pom.xml
index 47ad4c9a021b35fdb9e020571df7f5c0262e6313..d4dbdaf4c35159a38fd1970fee6e28a52075f765 100644
--- a/pom.xml
+++ b/pom.xml
@@ -166,6 +166,13 @@
             <artifactId>commons-math3</artifactId>
             <version>3.6.1</version>
         </dependency>
+        <!-- Hardware aceleration -->
+        <dependency>
+            <groupId>net.yatopia</groupId>
+            <artifactId>Yatopia-Hwaccel-All</artifactId>
+            <version>0.0.1-SNAPSHOT</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <repositories>
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 6e4e183c3169a484f482d96ba3441eb16c2053d9..02f309d00b6687c16a31f43386b915afcc40538d 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -19,6 +19,9 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import com.destroystokyo.paper.exception.ServerInternalException;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import net.yatopia.lighting.api.LightEngineManager;
+import net.yatopia.server.hwaccel.LightEngineThreadedDelegate;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunkProvider;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -386,6 +389,8 @@ public class ChunkProviderServer extends IChunkProvider {
         file1.mkdirs();
         this.worldPersistentData = new WorldPersistentData(file1, datafixer);
         this.playerChunkMap = new PlayerChunkMap(worldserver, convertable_conversionsession, datafixer, definedstructuremanager, executor, this.serverThreadQueue, this, this.getChunkGenerator(), worldloadlistener, supplier, i, flag);
+        this.playerChunkMap.lightEngineImpl = LightEngineManager.create(new MinecraftChunkProvider(this), this.world.getDimensionManager().hasSkyLight(), this.playerChunkMap.lightThread);
+        this.playerChunkMap.lightEngine = new LightEngineThreadedDelegate(this.playerChunkMap.lightEngineImpl);
         this.lightEngine = this.playerChunkMap.a();
         this.chunkMapDistance = this.playerChunkMap.e();
         this.clearCache();
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index e5eb34da6994519b81bafab8241d680568cfcc84..46abbe16b6d2aca576948b2ba9f0780a4d7e40fd 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -188,6 +188,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             return false;
         }
         net.yatopia.server.YatopiaConfig.registerCommands();
+        net.yatopia.server.hwaccel.LightEngineRegistryHook.register();
         // Yatopia end
         de.minebench.origami.OrigamiConfig.init((java.io.File) options.valueOf("origami-settings"));
         this.setPVP(dedicatedserverproperties.pvp);
diff --git a/src/main/java/net/minecraft/server/LightEngineThreaded.java b/src/main/java/net/minecraft/server/LightEngineThreaded.java
index f3494ac1ad659352ca5595adf9e6919bdb4018d0..aac3a3083764509992e008ac29bde8ea3d080b3f 100644
--- a/src/main/java/net/minecraft/server/LightEngineThreaded.java
+++ b/src/main/java/net/minecraft/server/LightEngineThreaded.java
@@ -1,14 +1,24 @@
 package net.minecraft.server;
 
-import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap; // Paper
-import it.unimi.dsi.fastutil.objects.ObjectArrayList;
-import it.unimi.dsi.fastutil.objects.ObjectList;
-import it.unimi.dsi.fastutil.objects.ObjectListIterator;
+
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.IntSupplier;
 import javax.annotation.Nullable;
+
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.structures.Chunk;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.ChunkSectionPosition;
+import net.yatopia.lighting.api.structures.LightAccessor;
+import net.yatopia.lighting.api.structures.LightType;
+import net.yatopia.server.hwaccel.adapter.BlockPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkSectionPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunk;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.VanillaLightingAccessor;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.storage.UnpooledNibbleArray;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -188,7 +198,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
         }));
     }
 
-    protected void a(ChunkCoordIntPair chunkcoordintpair) {
+    public void a(ChunkCoordIntPair chunkcoordintpair) {
         this.a(chunkcoordintpair.x, chunkcoordintpair.z, () -> {
             return 0;
         }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
@@ -233,10 +243,11 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
 
     @Override
     public void a(EnumSkyBlock enumskyblock, SectionPosition sectionposition, @Nullable NibbleArray nibblearray, boolean flag) {
+        NibbleArray nArray = nibblearray instanceof UnpooledNibbleArray ? new NibbleArray(nibblearray.asBytes()) : nibblearray;
         this.a(sectionposition.a(), sectionposition.c(), () -> {
             return 0;
         }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
-            super.a(enumskyblock, sectionposition, nibblearray, flag);
+            super.a(enumskyblock, sectionposition, nArray, flag);
         }, () -> {
             return "queueData " + sectionposition;
         }));
@@ -335,7 +346,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
             post.clear();
         } else {
             // might have level updates to go still
-            super.a(Integer.MAX_VALUE, true, true);
+            super.a(4, true, true);
         }
         // Paper end
     }
@@ -348,6 +359,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
 
         PRE_UPDATE, POST_UPDATE;
 
-        private Update() {}
+        private Update() {
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
index 4085426af03f032cf405bdfd1e40a8e5dc27c1d1..820274bc97f55a12b4db7786b5cbd3789f0ebc6b 100644
--- a/src/main/java/net/minecraft/server/NibbleArray.java
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -63,7 +63,7 @@ public class NibbleArray {
         }
     }
     // Paper end
-    @Nullable protected byte[] a;
+    @Nullable protected byte[] a = null;
 
 
     public NibbleArray() {}
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 80cc96a4de5a5af964dfc6e77911426e8536fbce..1e77a0b502dc443726576d4f41e2aab51a613c1b 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -755,7 +755,7 @@ public class PlayerChunk {
                 ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
             }
             chunkMap.world.asyncChunkTaskManager.raisePriority(location.x, location.z, ioPriority);
-            chunkMap.world.getChunkProvider().getLightEngine().queue.changePriority(location.pair(), getCurrentPriority(), priority);
+            // chunkMap.world.getChunkProvider().getLightEngine().queue.changePriority(location.pair(), getCurrentPriority(), priority); TODO RIP priority
         }
         if (getCurrentPriority() != priority) {
             this.u.a(this.location, this::getCurrentPriority, priority, this::setPriority); // use preferred priority
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index de0950327d156056d150ad0b59893fa97fb069d6..886c8620f532fe1232e2f56319918ef936f7768a 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -4,10 +4,7 @@ import co.aikar.timings.Timing; // Paper
 import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
@@ -25,11 +22,9 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
-import java.util.HashMap; // Paper
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
@@ -39,6 +34,7 @@ import java.util.UUID; // Paper
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -48,7 +44,13 @@ import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.LightEngineManager;
+import net.yatopia.lighting.api.structures.ChunkProvider;
+import net.yatopia.server.hwaccel.LightEngineThreadedDelegate;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunkProvider;
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -89,7 +91,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
-    private final LightEngineThreaded lightEngine;
+    LightEngineThreaded lightEngine;
+    LightEngineImpl lightEngineImpl;
     private final IAsyncTaskHandler<Runnable> executor;
     final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public final ChunkGenerator chunkGenerator;
@@ -304,7 +307,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager<RegionData> dataRegionManager;
     // Tuiniy end
 
-    private final java.util.concurrent.ExecutorService lightThread;
+    final java.util.concurrent.ExecutorService lightThread;
     public PlayerChunkMap(WorldServer worldserver, Convertable.ConversionSession convertable_conversionsession, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i, boolean flag) {
         super(new File(convertable_conversionsession.a(worldserver.getDimensionKey()), "region"), datafixer, flag);
         //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
@@ -351,8 +354,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.mailboxWorldGen = this.p.a(threadedmailbox, false);
         this.mailboxMain = this.p.a(mailbox, false);
         this.mailboxLight = this.p.a(lightthreaded, false);// Paper
-        this.lightEngine = new LightEngineThreaded(ilightaccess, this, this.world.getDimensionManager().hasSkyLight(), threadedmailbox1, this.p.a(threadedmailbox1, false));
-        this.chunkDistanceManager = new PlayerChunkMap.a(executor, iasynctaskhandler); this.chunkDistanceManager.chunkMap = this; // Paper
+        // Yatopia - moved
+        // this.lightEngineImpl = new LightEngineThreaded(ilightaccess, this, this.world.getDimensionManager().hasSkyLight(), threadedmailbox1, this.p.a(threadedmailbox1, false));
+        this.chunkDistanceManager = new PlayerChunkMap.a(executor, iasynctaskhandler);
+        this.chunkDistanceManager.chunkMap = this; // Paper
         this.l = supplier;
         this.m = new VillagePlace(new File(this.w, "poi"), datafixer, flag, this.world); // Paper
         this.setViewDistance(i);
diff --git a/src/main/java/net/minecraft/server/ProtoChunk.java b/src/main/java/net/minecraft/server/ProtoChunk.java
index a3ac883500eaebb353ad3108a17b5c740e384b03..2227c46cd2d553b651c0d98dcde3a605ca18bba8 100644
--- a/src/main/java/net/minecraft/server/ProtoChunk.java
+++ b/src/main/java/net/minecraft/server/ProtoChunk.java
@@ -47,6 +47,7 @@ public class ProtoChunk implements IChunkAccess {
     private final Map<WorldGenStage.Features, BitSet> t;
     private volatile boolean u;
     final World world; // Paper - Anti-Xray - Add world // Paper - private -> default
+    public World getWorld() { return world; } // Yatopia - Accessor
 
     // Paper start - Anti-Xray - Add world
     @Deprecated public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter) { this(chunkcoordintpair, chunkconverter, null); } // Notice for updates: Please make sure this constructor isn't used anywhere
diff --git a/src/main/java/net/yatopia/server/YatopiaConfig.java b/src/main/java/net/yatopia/server/YatopiaConfig.java
index 5139279822b1fdc4a60de5abc76e81c75fe2e6bb..850124c7648bf400c2d5f60db031603a268632d4 100644
--- a/src/main/java/net/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/net/yatopia/server/YatopiaConfig.java
@@ -1,6 +1,16 @@
 package net.yatopia.server;
 
 import com.google.common.base.Throwables;
+import net.minecraft.server.MinecraftServer;
+import net.yatopia.hwaccel.opencl.OpenCLConfiguration;
+import net.yatopia.hwaccel.utils.ConfigSuppliers;
+import net.yatopia.lighting.api.LightingConfiguration;
+import net.yatopia.server.hwaccel.OpenCLCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -12,11 +22,6 @@ import java.util.Map;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.regex.Pattern;
-import net.minecraft.server.MinecraftServer;
-import org.bukkit.Bukkit;
-import org.bukkit.command.Command;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.bukkit.configuration.file.YamlConfiguration;
 
 public class YatopiaConfig {
 
@@ -46,6 +51,7 @@ public class YatopiaConfig {
         verbose = getBoolean("verbose", false);
         commands = new HashMap<>();
         commands.put("nspt", new NSPTCommand("nspt"));
+        commands.put("opencl", new OpenCLCommand("opencl"));
 
         version = getInt("config-version", 1);
         set("config-version", 1);
@@ -283,4 +289,13 @@ public class YatopiaConfig {
         checkVehicleMovedQuickly = getBoolean("settings.checks.vehicle-moved-quickly", checkVehicleMovedQuickly);
         checkVehicleMovedWrongly = getBoolean("settings.checks.vehicle-moved-wrongly", checkVehicleMovedWrongly);
     }
+
+    private static void hwaccelConfig() {
+        ConfigSuppliers.stringConfigSupplier = YatopiaConfig::getString;
+        ConfigSuppliers.integerConfigSupplier = YatopiaConfig::getInt;
+        ConfigSuppliers.doubleConfigSupplier = YatopiaConfig::getDouble;
+        ConfigSuppliers.booleanConfigSupplier = YatopiaConfig::getBoolean;
+        OpenCLConfiguration.reload();
+        LightingConfiguration.reload();
+    }
 }
diff --git a/src/main/java/net/yatopia/server/hwaccel/LightEngineImplDelegate.java b/src/main/java/net/yatopia/server/hwaccel/LightEngineImplDelegate.java
new file mode 100644
index 0000000000000000000000000000000000000000..797d56a8d74d61c1abb6a5d0b9d6712751718dc9
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/LightEngineImplDelegate.java
@@ -0,0 +1,93 @@
+package net.yatopia.server.hwaccel;
+
+import net.minecraft.server.EnumSkyBlock;
+import net.minecraft.server.LightEngineThreaded;
+import net.minecraft.server.NibbleArray;
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.structures.Chunk;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.ChunkSectionPosition;
+import net.yatopia.lighting.api.structures.LightAccessor;
+import net.yatopia.lighting.api.structures.LightType;
+import net.yatopia.server.hwaccel.adapter.BlockPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkSectionPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunk;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.VanillaLightingAccessor;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.storage.UnpooledNibbleArray;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletableFuture;
+
+public class LightEngineImplDelegate implements LightEngineImpl {
+
+    private final LightEngineThreaded delegate;
+
+    public LightEngineImplDelegate(LightEngineThreaded delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public int doLightUpdates(int maxUpdateCount, boolean doSkylight, boolean skipEdgeLightPropagation) {
+        return delegate.a(maxUpdateCount, doSkylight, skipEdgeLightPropagation);
+    }
+
+    @Override
+    public void addLightSource(net.yatopia.lighting.api.structures.BlockPosition pos, int level) {
+        delegate.a(BlockPositionAdapter.toNMS(pos), level);
+    }
+
+    @Override
+    public void checkBlock(net.yatopia.lighting.api.structures.BlockPosition pos) {
+        delegate.a(BlockPositionAdapter.toNMS(pos));
+    }
+
+    @Override
+    public void updateChunkStatus(ChunkPosition pos) {
+        delegate.a(ChunkPositionAdapter.toNMS(pos));
+    }
+
+    @Override
+    public void setSectionStatus(ChunkSectionPosition pos, boolean notReady) {
+        delegate.a(ChunkSectionPositionAdapter.toNMS(pos), notReady);
+    }
+
+    @Override
+    public void setColumnEnabled(ChunkPosition pos, boolean lightEnabled) {
+        delegate.a(ChunkPositionAdapter.toNMS(pos), lightEnabled);
+    }
+
+    @Override
+    public void enqueueSectionData(LightType lightType, ChunkSectionPosition pos, @Nullable byte[] nibbles, boolean flag) {
+        delegate.a(EnumSkyBlock.valueOf(lightType.name()), ChunkSectionPositionAdapter.toNMS(pos), new UnpooledNibbleArray(nibbles), flag);
+    }
+
+    @Override
+    public void setRetainData(ChunkPosition pos, boolean retainData) {
+        delegate.b(ChunkPositionAdapter.toNMS(pos), retainData);
+    }
+
+    @Override
+    public CompletableFuture<Void> lightChunk(Chunk chunk, boolean excludeBlocks) {
+        return delegate.a(((MinecraftChunk)chunk).handle, excludeBlocks).handle((iChunkAccess, throwable) -> {
+            if(throwable != null)
+                throwable.printStackTrace();
+            return null;
+        });
+    }
+
+    @Override
+    public LightAccessor get(LightType lightType) {
+        return new VanillaLightingAccessor(delegate.a(EnumSkyBlock.valueOf(lightType.name())));
+    }
+
+    @Override
+    public int getLight(net.yatopia.lighting.api.structures.BlockPosition pos, int ambientDarkness) {
+        return delegate.b(BlockPositionAdapter.toNMS(pos), ambientDarkness);
+    }
+
+    @Override
+    public void close() {
+        delegate.close();
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/LightEngineRegistryHook.java b/src/main/java/net/yatopia/server/hwaccel/LightEngineRegistryHook.java
new file mode 100644
index 0000000000000000000000000000000000000000..abb4ad7f19d5734bebc315962583ac22b689b1f0
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/LightEngineRegistryHook.java
@@ -0,0 +1,25 @@
+package net.yatopia.server.hwaccel;
+
+import net.minecraft.server.LightEngineThreaded;
+import net.minecraft.server.ThreadedMailbox;
+import net.yatopia.hwaccel.utils.registry.Identifier;
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.registry.LightEngineImplProvider;
+import net.yatopia.lighting.api.registry.LightEngineRegistry;
+import net.yatopia.lighting.api.structures.ChunkProvider;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunkProvider;
+
+import java.util.concurrent.ExecutorService;
+
+public class LightEngineRegistryHook {
+
+    public static void register() {
+        LightEngineRegistry.LIGHT_ENGINE_IMPL_PROVIDERS.register(new Identifier("minecraft", "vanilla"), new LightEngineImplProvider() {
+            @Override
+            public LightEngineImpl create(ChunkProvider chunkProvider, boolean hasSkylight, ExecutorService lightThread) {
+                return new LightEngineImplDelegate(new LightEngineThreaded(((MinecraftChunkProvider)chunkProvider).handle, ((MinecraftChunkProvider)chunkProvider).handle.playerChunkMap, hasSkylight, ThreadedMailbox.a(lightThread, "light"), null));
+            }
+        });
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/LightEngineThreadedDelegate.java b/src/main/java/net/yatopia/server/hwaccel/LightEngineThreadedDelegate.java
new file mode 100644
index 0000000000000000000000000000000000000000..654c4361d41b8b6d39eaa8a8cab7abae0dfc4459
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/LightEngineThreadedDelegate.java
@@ -0,0 +1,128 @@
+package net.yatopia.server.hwaccel;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.EnumSkyBlock;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.LightEngineLayerEventListener;
+import net.minecraft.server.LightEngineThreaded;
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.SectionPosition;
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.structures.LightType;
+import net.yatopia.server.hwaccel.adapter.BlockPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkSectionPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunk;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.VanillaChunkLightingViewDelegate;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletableFuture;
+
+public class LightEngineThreadedDelegate extends LightEngineThreaded {
+
+    final LightEngineImpl delegate;
+
+    public LightEngineThreadedDelegate(LightEngineImpl delegate) {
+        super(null, null, false, null, null);
+        this.delegate = delegate;
+    }
+
+    @Override
+    public void a(BlockPosition var0) {
+        delegate.checkBlock(BlockPositionAdapter.fromNMS(var0));
+    }
+
+    @Override
+    public void a(BlockPosition var0, int var1) {
+        delegate.addLightSource(BlockPositionAdapter.fromNMS(var0), var1);
+    }
+
+    @Override
+    public boolean a() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int a(int var0, boolean var1, boolean var2) {
+        return delegate.doLightUpdates(var0, var1, var2);
+    }
+
+    @Override
+    public void a(SectionPosition var0, boolean var1) {
+        delegate.setSectionStatus(ChunkSectionPositionAdapter.fromNMS(var0), var1);
+    }
+
+    @Override
+    public void a(ChunkCoordIntPair var0, boolean var1) {
+        delegate.setColumnEnabled(ChunkPositionAdapter.fromNMS(var0), var1);
+    }
+
+    @Override
+    public LightEngineLayerEventListener a(EnumSkyBlock var0) {
+        return new VanillaChunkLightingViewDelegate(delegate.get(LightType.valueOf(var0.name())));
+    }
+
+    @Override
+    public void a(EnumSkyBlock var0, SectionPosition var1, @Nullable NibbleArray var2, boolean var3) {
+        delegate.enqueueSectionData(LightType.valueOf(var0.name()), ChunkSectionPositionAdapter.fromNMS(var1), var2 != null ? var2.asBytes() : null, var3);
+        // if(var2 != null && var2.cleaner != null) var2.cleaner.run();
+    }
+
+    @Override
+    public void b(ChunkCoordIntPair var0, boolean var1) {
+        delegate.setRetainData(ChunkPositionAdapter.fromNMS(var0), var1);
+    }
+
+    @Override
+    public int b(BlockPosition var0, int var1) {
+        return delegate.getLight(BlockPositionAdapter.fromNMS(var0), var1);
+    }
+
+    @Override
+    public void a(BlockPosition var0, boolean var1) {
+        delegate.setSectionStatus(ChunkSectionPositionAdapter.fromNMS(SectionPosition.a(var0)), var1);
+    }
+
+    @Override
+    public int hashCode() {
+        return delegate.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return delegate.equals(obj);
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + " -> " + delegate.toString();
+    }
+
+    @Override
+    public void close() {
+        super.close();
+    }
+
+    @Override
+    public CompletableFuture<IChunkAccess> a(IChunkAccess ichunkaccess, boolean flag) {
+        return delegate.lightChunk(new MinecraftChunk(ichunkaccess), flag).handle((unused, throwable) -> {
+            if(throwable != null)
+                throwable.printStackTrace();
+            return ichunkaccess;
+        });
+    }
+
+    @Override
+    public void a(ChunkCoordIntPair chunkcoordintpair) {
+        delegate.updateChunkStatus(ChunkPositionAdapter.fromNMS(chunkcoordintpair));
+    }
+
+    @Override
+    public void queueUpdate() {
+    }
+
+    @Override
+    public void a(int i) { // setQueueSize
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/OpenCLCommand.java b/src/main/java/net/yatopia/server/hwaccel/OpenCLCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c08a02bde20e5e57d7228a7a261435eb78eb05ac
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/OpenCLCommand.java
@@ -0,0 +1,72 @@
+package net.yatopia.server.hwaccel;
+
+import com.destroystokyo.paper.PaperCommand;
+import net.yatopia.hwaccel.opencl.OpenCLConfiguration;
+import net.yatopia.hwaccel.opencl.OpenCompute;
+import org.apache.logging.log4j.LogManager;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.util.List;
+
+public class OpenCLCommand extends Command {
+
+    public OpenCLCommand(String name) {
+        super(name);
+        this.description = "OpenCL related post-launch functions";
+        this.usageMessage = "/opencl";
+        this.setPermission("bukkit.command.opencl");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (Boolean.parseBoolean(System.getProperty("Yatopia.OpenCLDebug", "true"))) {
+            return PaperCommand.getListMatchingLast(args, "info", "reload", "enable", "override");
+        }
+        return PaperCommand.getListMatchingLast(args, "info");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+
+        if (OpenCompute.getActiveInstance() == null) {
+            sender.sendMessage("Your system does not support OpenCL, OpenCL has been explicitly disabled");
+            sender.sendMessage("Check startup logs for more info");
+            return true;
+        }
+
+        if (args.length <= 0) {
+            sender.sendMessage(String.format("Using %s for OpenCL acceleration", OpenCompute.getActiveInstance().getDevice().getName()));
+            return true;
+        }
+
+        if (args[0].equals("info")) {
+            sender.sendMessage(String.format("Using %s for OpenCL acceleration", OpenCompute.getActiveInstance().getDevice().getName()));
+            return true;
+        }
+
+        if (Boolean.parseBoolean(System.getProperty("Yatopia.OpenCLDebug", "true"))) {
+            if (args[0].equals("reload")) {
+                try {
+                    sender.sendMessage("Reloading OpenCL");
+                    sender.sendMessage("Shutting down OpenCL");
+                    OpenCompute.release();
+                    sender.sendMessage("Starting OpenCL");
+                    OpenCLConfiguration.useOpenCL = true;
+                    OpenCompute.init();
+                    sender.sendMessage("OpenCL has been successfully reloaded");
+                } catch (Exception e) {
+                    LogManager.getLogger().error(e);
+                    sender.sendMessage("Error Reloading OpenCL");
+                }
+                return true;
+            }
+        }
+
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/BlockPositionAdapter.java b/src/main/java/net/yatopia/server/hwaccel/adapter/BlockPositionAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f057572cfd199677c957c1c89539d5c72db8886
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/BlockPositionAdapter.java
@@ -0,0 +1,15 @@
+package net.yatopia.server.hwaccel.adapter;
+
+import net.yatopia.lighting.api.structures.BlockPosition;
+
+public class BlockPositionAdapter {
+
+    public static BlockPosition fromNMS(net.minecraft.server.BlockPosition var0){
+        return new BlockPosition(var0.getX(), var0.getY(), var0.getZ());
+    }
+
+    public static net.minecraft.server.BlockPosition toNMS(BlockPosition var0) {
+        return new net.minecraft.server.BlockPosition(var0.x, var0.y, var0.z);
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkPositionAdapter.java b/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkPositionAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..32d51ed9a42c91d57fcbafab71c5fb490a07c0c7
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkPositionAdapter.java
@@ -0,0 +1,16 @@
+package net.yatopia.server.hwaccel.adapter;
+
+import net.minecraft.server.ChunkCoordIntPair;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+
+public class ChunkPositionAdapter {
+
+    public static ChunkPosition fromNMS(ChunkCoordIntPair var0) {
+        return new ChunkPosition(var0.x, var0.z);
+    }
+
+    public static ChunkCoordIntPair toNMS(ChunkPosition var0) {
+        return new ChunkCoordIntPair(var0.x, var0.z);
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkSectionPositionAdapter.java b/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkSectionPositionAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..5df3b88770d276558866c3e20d2cfb3f1f8c5f2d
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/ChunkSectionPositionAdapter.java
@@ -0,0 +1,16 @@
+package net.yatopia.server.hwaccel.adapter;
+
+import net.minecraft.server.SectionPosition;
+import net.yatopia.lighting.api.structures.ChunkSectionPosition;
+
+public class ChunkSectionPositionAdapter {
+
+    public static ChunkSectionPosition fromNMS(SectionPosition var0){
+        return new ChunkSectionPosition(var0.getX(), var0.getY(), var0.getZ());
+    }
+
+    public static SectionPosition toNMS(ChunkSectionPosition var0){
+        return SectionPosition.a(var0.x, var0.y, var0.z);
+    }
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/LightAccessorAdapter.java b/src/main/java/net/yatopia/server/hwaccel/adapter/LightAccessorAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5cf730fd7b15586b24f681a5ca78894a0c95166
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/LightAccessorAdapter.java
@@ -0,0 +1,9 @@
+package net.yatopia.server.hwaccel.adapter;
+
+public class LightAccessorAdapter {
+
+
+
+
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunk.java b/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2403ec94c786a4819a5c6dab3b762fd47d1b75d
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunk.java
@@ -0,0 +1,30 @@
+package net.yatopia.server.hwaccel.adapter.chunkprovider;
+
+import net.minecraft.server.IChunkAccess;
+import net.yatopia.lighting.api.structures.Chunk;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+
+public class MinecraftChunk extends Chunk {
+
+    public final IChunkAccess handle;
+
+    public MinecraftChunk(IChunkAccess handle) {
+        super(ChunkPositionAdapter.fromNMS(handle.getPos()));
+        this.handle = handle;
+    }
+
+    public int hashCode() {
+        return chunkPosition.hashCode();
+    }
+
+    public boolean equals(Object that) {
+        if(!(that instanceof MinecraftChunk)) return false;
+        return chunkPosition.equals(((Chunk)that).chunkPosition);
+    }
+
+    public String toString(){
+        return chunkPosition.toString();
+    }
+
+
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunkProvider.java b/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunkProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddd2108cc989243ee94bb7295ac5c9b143b6ceed
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/chunkprovider/MinecraftChunkProvider.java
@@ -0,0 +1,22 @@
+package net.yatopia.server.hwaccel.adapter.chunkprovider;
+
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.WorldDataServer;
+import net.yatopia.lighting.api.structures.ChunkProvider;
+
+import javax.annotation.Nonnull;
+
+public class MinecraftChunkProvider implements ChunkProvider {
+
+    public final ChunkProviderServer handle;
+
+    public MinecraftChunkProvider(ChunkProviderServer handle) {
+        this.handle = handle;
+    }
+
+    @Nonnull
+    @Override
+    public String getWorldName() {
+        return ((WorldDataServer) handle.getWorld().getWorldData()).getName();
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaChunkLightingViewDelegate.java b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaChunkLightingViewDelegate.java
new file mode 100644
index 0000000000000000000000000000000000000000..19e0b7e0bfee233622544c07a6c6f055c06afa5d
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaChunkLightingViewDelegate.java
@@ -0,0 +1,36 @@
+package net.yatopia.server.hwaccel.adapter.lightaccessor;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.LightEngineLayerEventListener;
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.SectionPosition;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.LightAccessor;
+import net.yatopia.server.hwaccel.adapter.BlockPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.storage.UnpooledNibbleArray;
+
+import javax.annotation.Nullable;
+
+public class VanillaChunkLightingViewDelegate implements LightEngineLayerEventListener {
+    private final LightAccessor delegate;
+
+    public VanillaChunkLightingViewDelegate(LightAccessor delegate) {
+        this.delegate = delegate;
+    }
+
+    @Nullable
+    @Override
+    public NibbleArray a(SectionPosition sectionposition) {
+        return new UnpooledNibbleArray(delegate.getLightStorage(new ChunkPosition(sectionposition.getX(), sectionposition.getZ())).getSection(sectionposition.getY()));
+    }
+
+    @Override
+    public int b(BlockPosition blockposition) {
+        return delegate.getLightLevel(BlockPositionAdapter.fromNMS(blockposition));
+    }
+
+    @Override
+    public void a(SectionPosition sectionPosition, boolean b) {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaLightingAccessor.java b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaLightingAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3bd6235c54187e52dfe174b379274c823176051
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/VanillaLightingAccessor.java
@@ -0,0 +1,29 @@
+package net.yatopia.server.hwaccel.adapter.lightaccessor;
+
+import net.minecraft.server.LightEngineLayerEventListener;
+import net.yatopia.lighting.api.storage.ChunkLightStorage;
+import net.yatopia.lighting.api.structures.BlockPosition;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.LightAccessor;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.lightaccessor.storage.NibbleArrayChunkStorage;
+
+public class VanillaLightingAccessor implements LightAccessor {
+
+    private final LightEngineLayerEventListener delegate;
+
+    public VanillaLightingAccessor(LightEngineLayerEventListener delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public NibbleArrayChunkStorage getLightStorage(ChunkPosition chunkPosition) {
+        return new NibbleArrayChunkStorage(delegate, ChunkPositionAdapter.toNMS(chunkPosition));
+    }
+
+    @Override
+    public byte getLightLevel(BlockPosition blockPosition) {
+        return this.getLightStorage(new ChunkPosition(blockPosition.x >> 4, blockPosition.z >> 4))
+                .getLight(blockPosition.x % 16, blockPosition.y, blockPosition.z % 16);
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/NibbleArrayChunkStorage.java b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/NibbleArrayChunkStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..10f8e92e4e750847207660123e5e5c9c9f5e4695
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/NibbleArrayChunkStorage.java
@@ -0,0 +1,77 @@
+package net.yatopia.server.hwaccel.adapter.lightaccessor.storage;
+
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.LightEngineLayerEventListener;
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.SectionPosition;
+import net.yatopia.lighting.api.storage.ChunkLightStorage;
+
+import java.util.Arrays;
+
+public class NibbleArrayChunkStorage implements ChunkLightStorage {
+
+    private final LightEngineLayerEventListener lightAccessor;
+    private final ChunkCoordIntPair chunkPos;
+
+    public NibbleArrayChunkStorage(LightEngineLayerEventListener lightAccessor, ChunkCoordIntPair chunkPos) {
+        this.lightAccessor = lightAccessor;
+        this.chunkPos = chunkPos;
+    }
+
+    @Override
+    public byte[] getArrayCopy() {
+        byte[] bytes = new byte[32678];
+        Arrays.fill(bytes, (byte) 0x00);
+        for (int i = 0; i < 16; i++) {
+            NibbleArray nibbleArray = lightAccessor.a(SectionPosition.a(chunkPos, i));
+            if (nibbleArray != null)
+                System.arraycopy(nibbleArray.asBytes(), 0, bytes, i << 11, 2048);
+        }
+        return bytes;
+    }
+
+    @Override
+    public byte[] getSectionCopy(int index) {
+        NibbleArray nibbleArray = lightAccessor.a(SectionPosition.a(chunkPos, index));
+        if (nibbleArray != null)
+            return nibbleArray.asBytes().clone();
+        else {
+            byte[] bytes = new byte[2048];
+            Arrays.fill(bytes, (byte) 0x00);
+            return bytes;
+        }
+    }
+
+    @Override
+    public byte[] getArray() {
+        return getArrayCopy();
+    }
+
+    @Override
+    public byte[] getSection(int index) {
+        NibbleArray nibbleArray = lightAccessor.a(SectionPosition.a(chunkPos, index));
+        if (nibbleArray != null)
+            return nibbleArray.asBytes();
+        else {
+            byte[] bytes = new byte[2048];
+            Arrays.fill(bytes, (byte) 0x00);
+            return bytes;
+        }
+    }
+
+    @Override
+    public void setByte(int index, byte value) {
+        NibbleArray nibbleArray = lightAccessor.a(SectionPosition.a(chunkPos, index << 11));
+        if(nibbleArray == null)
+            throw new IllegalStateException("NibbleArray not initialized yet");
+        nibbleArray.asBytes()[index % 2048] = value;
+    }
+
+    @Override
+    public byte getByte(int index) {
+        NibbleArray nibbleArray = lightAccessor.a(SectionPosition.a(chunkPos, index << 11));
+        if(nibbleArray == null)
+            return 0;
+        return nibbleArray.asBytes()[index % 2048];
+    }
+}
diff --git a/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/UnpooledNibbleArray.java b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/UnpooledNibbleArray.java
new file mode 100644
index 0000000000000000000000000000000000000000..488430d7f06adc15cef632930fb081e08bca9034
--- /dev/null
+++ b/src/main/java/net/yatopia/server/hwaccel/adapter/lightaccessor/storage/UnpooledNibbleArray.java
@@ -0,0 +1,147 @@
+package net.yatopia.server.hwaccel.adapter.lightaccessor.storage;
+
+import net.minecraft.server.NibbleArray;
+import net.minecraft.server.SystemUtils;
+
+import javax.annotation.Nonnull;
+
+public class UnpooledNibbleArray extends NibbleArray {
+
+    {
+        cleaner = () -> {
+        };
+    }
+
+    public UnpooledNibbleArray() {
+    }
+
+    public UnpooledNibbleArray(byte[] abyte) {
+        if(abyte == null) return;
+        this.a = abyte;
+        if (abyte.length != 2048) {
+            throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + abyte.length)));
+        }
+    }
+
+    protected UnpooledNibbleArray(int i) {
+        this.a = new byte[i];
+    }
+
+    public int a(int i, int j, int k) {
+        return this.b(this.b(i, j, k));
+    }
+
+    public void a(int i, int j, int k, int l) {
+        this.a(this.b(i, j, k), l);
+    }
+
+    protected int b(int i, int j, int k) {
+        return j << 8 | k << 4 | i;
+    }
+
+    public int b(int i) {
+        if (this.a == null) {
+            return 0;
+        } else {
+            int j = this.d(i);
+
+            return this.a[j] >> ((i & 1) << 2) & 15;
+        }
+    }
+
+    public void a(int i, int j) {
+        if (this.a == null) {
+            this.a = new byte[2048];
+        }
+
+        int k = this.d(i);
+
+        int shift = (i & 1) << 2;
+        this.a[k] = (byte) (this.a[k] & ~(15 << shift) | (j & 15) << shift);
+
+    }
+
+    private boolean c(int i) {
+        return (i & 1) == 0;
+    }
+
+    private int d(int i) {
+        return i >> 1;
+    }
+
+    public byte[] asBytes() {
+        if (this.a == null) {
+            this.a = new byte[2048];
+        }
+
+        return this.a;
+    }
+
+    public NibbleArray b() {
+        return this.a == null ? new UnpooledNibbleArray() : new UnpooledNibbleArray((byte[]) this.a.clone());
+    }
+
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder();
+
+        for (int i = 0; i < 4096; ++i) {
+            stringbuilder.append(Integer.toHexString(this.b(i)));
+            if ((i & 15) == 15) {
+                stringbuilder.append("\n");
+            }
+
+            if ((i & 255) == 255) {
+                stringbuilder.append("\n");
+            }
+        }
+
+        return stringbuilder.toString();
+    }
+
+    public boolean c() {
+        return this.a == null;
+    }
+
+    @Override
+    public NibbleArray markPoolSafe() {
+        return this;
+    }
+
+    @Override
+    public byte[] getCloneIfSet() {
+        if (a == null) {
+            return EMPTY_NIBBLE;
+        }
+        byte[] ret = new byte[2048];
+        System.arraycopy(getIfSet(), 0, ret, 0, 2048);
+        return ret;
+    }
+
+    @Override
+    public NibbleArray cloneAndSet(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE) {
+            this.a = new byte[2048];
+            System.arraycopy(bytes, 0, this.a, 0, 2048);
+        }
+        return this;
+    }
+
+    public UnpooledNibbleArray(byte[] abyte, boolean isSafe) {
+        this(abyte);
+    }
+
+    @Nonnull
+    @Override
+    public byte[] asBytesPoolSafe() {
+        return this.a != null ? this.a : EMPTY_NIBBLE;
+    }
+
+    @Override
+    public NibbleArray copy() {
+        return super.copy();
+    }
+
+    @Override
+    protected void finalize() {
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index b189c4011000106631b98a7ca87bd9d114aaf350..f1b0d5d9f635abd8736f78954c358af15bf11617 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -7,12 +7,12 @@ import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import net.yatopia.hwaccel.opencl.OpenCompute;
 
 public class Main {
     public static boolean useJline = true;
@@ -305,6 +305,7 @@ public class Main {
                 System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
                 //de.minebench.origami.OrigamiConfig.init((java.io.File) options.valueOf("origami-settings")); // Origami - Server Config // Yatopia - no load here for u
                 System.out.println("Loading libraries, please wait...");
+                OpenCompute.init(); // Yatopia
                 net.minecraft.server.Main.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
diff --git a/src/test/java/net/yatopia/server/hwaccel/AdapterTest.java b/src/test/java/net/yatopia/server/hwaccel/AdapterTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..91e4e9e47bf8b4daea4e352c037b4a7717a4e68f
--- /dev/null
+++ b/src/test/java/net/yatopia/server/hwaccel/AdapterTest.java
@@ -0,0 +1,337 @@
+package net.yatopia.server.hwaccel;
+
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.shorts.ShortList;
+import net.minecraft.server.BiomeStorage;
+import net.minecraft.server.Block;
+import net.minecraft.server.ChunkConverter;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.Entity;
+import net.minecraft.server.Fluid;
+import net.minecraft.server.FluidType;
+import net.minecraft.server.HeightMap;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.StructureGenerator;
+import net.minecraft.server.StructureStart;
+import net.minecraft.server.TickList;
+import net.minecraft.server.TileEntity;
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.structures.BlockPosition;
+import net.yatopia.lighting.api.structures.Chunk;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.ChunkSectionPosition;
+import net.yatopia.lighting.api.structures.LightType;
+import net.yatopia.server.hwaccel.adapter.BlockPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.ChunkSectionPositionAdapter;
+import net.yatopia.server.hwaccel.adapter.chunkprovider.MinecraftChunk;
+import net.yatopia.server.hwaccel.structure.TestingLightEngineImpl;
+import org.junit.Assert;
+import org.junit.Test;
+
+import javax.annotation.Nullable;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.stream.Stream;
+
+public class AdapterTest {
+
+    private static final int TEST_SIZE = 2048;
+
+    @Test
+    public void testBlockPositionAdapter() {
+        Random random = new Random();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            BlockPosition blockPosition = new BlockPosition(random.nextInt(), random.nextInt(), random.nextInt());
+            Assert.assertEquals(blockPosition, BlockPositionAdapter.fromNMS(BlockPositionAdapter.toNMS(blockPosition)));
+        }
+    }
+
+    @Test
+    public void testChunkPositionAdapter() {
+        Random random = new Random();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            ChunkPosition blockPosition = new ChunkPosition(random.nextInt(), random.nextInt());
+            Assert.assertEquals(blockPosition, ChunkPositionAdapter.fromNMS(ChunkPositionAdapter.toNMS(blockPosition)));
+        }
+    }
+
+    @Test
+    public void testChunkSectionPositionAdapter() {
+        Random random = new Random();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            ChunkSectionPosition blockPosition = new ChunkSectionPosition(random.nextInt(), random.nextInt(), random.nextInt());
+            Assert.assertEquals(blockPosition, ChunkSectionPositionAdapter.fromNMS(ChunkSectionPositionAdapter.toNMS(blockPosition)));
+        }
+    }
+
+    @Test
+    public void testLightEngineThreadedDelegate() throws IllegalAccessException, InvocationTargetException {
+        Random random = new Random();
+        LightEngineImpl impl = new TestingLightEngineImpl();
+        for(int i = 0; i < 16; i ++)
+            impl = new LightEngineImplDelegate(new LightEngineThreadedDelegate(impl));
+        Class<LightEngineImpl> clazz = LightEngineImpl.class;
+        Method[] methods = clazz.getMethods();
+        for(Method method: methods){
+            final Class<?>[] parameterTypes = method.getParameterTypes();
+            final Object[] parameters = new Object[parameterTypes.length];
+            for (int i = 0; i < parameterTypes.length; i++) {
+                Class<?> param = parameterTypes[i];
+                if (param == int.class)
+                    parameters[i] = random.nextInt();
+                else if(param == boolean.class)
+                    parameters[i] = random.nextBoolean();
+                else if(param == BlockPosition.class)
+                    parameters[i] = new BlockPosition(random.nextInt(), random.nextInt(), random.nextInt());
+                else if(param == ChunkPosition.class)
+                    parameters[i] = new ChunkPosition(random.nextInt(), random.nextInt());
+                else if(param == ChunkSectionPosition.class)
+                    parameters[i] = new ChunkSectionPosition(random.nextInt(), random.nextInt(), random.nextInt());
+                else if(param == LightType.class)
+                    parameters[i] = LightType.values()[random.nextBoolean() ? 0 : 1];
+                else if (param == byte[].class)
+                    parameters[i] = generateNibble();
+                else if(param == Chunk.class) {
+                    final ChunkPosition chunkPosition = new ChunkPosition(random.nextInt(), random.nextInt());
+                    parameters[i] = new MinecraftChunk(new IChunkAccess() {
+                        @Override
+                        public IBlockData getType(int x, int y, int z) {
+                            return null;
+                        }
+
+                        @Nullable
+                        @Override
+                        public IBlockData setType(net.minecraft.server.BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+                            return null;
+                        }
+
+                        @Override
+                        public void setTileEntity(net.minecraft.server.BlockPosition blockposition, TileEntity tileentity) {
+
+                        }
+
+                        @Override
+                        public void a(Entity entity) {
+
+                        }
+
+                        @Override
+                        public Set<net.minecraft.server.BlockPosition> c() {
+                            return null;
+                        }
+
+                        @Override
+                        public ChunkSection[] getSections() {
+                            return new ChunkSection[0];
+                        }
+
+                        @Override
+                        public Collection<Map.Entry<HeightMap.Type, HeightMap>> f() {
+                            return null;
+                        }
+
+                        @Override
+                        public void a(HeightMap.Type heightmap_type, long[] along) {
+
+                        }
+
+                        @Override
+                        public HeightMap a(HeightMap.Type heightmap_type) {
+                            return null;
+                        }
+
+                        @Override
+                        public int getHighestBlock(HeightMap.Type heightmap_type, int i, int j) {
+                            return 0;
+                        }
+
+                        @Override
+                        public ChunkCoordIntPair getPos() {
+                            return ChunkPositionAdapter.toNMS(chunkPosition);
+                        }
+
+                        @Override
+                        public void setLastSaved(long i) {
+
+                        }
+
+                        @Override
+                        public Map<StructureGenerator<?>, StructureStart<?>> h() {
+                            return null;
+                        }
+
+                        @Override
+                        public void a(Map<StructureGenerator<?>, StructureStart<?>> map) {
+
+                        }
+
+                        @Nullable
+                        @Override
+                        public BiomeStorage getBiomeIndex() {
+                            return null;
+                        }
+
+                        @Override
+                        public void setNeedsSaving(boolean flag) {
+
+                        }
+
+                        @Override
+                        public boolean isNeedsSaving() {
+                            return false;
+                        }
+
+                        @Override
+                        public ChunkStatus getChunkStatus() {
+                            return null;
+                        }
+
+                        @Override
+                        public void removeTileEntity(net.minecraft.server.BlockPosition blockposition) {
+
+                        }
+
+                        @Override
+                        public ShortList[] l() {
+                            return new ShortList[0];
+                        }
+
+                        @Nullable
+                        @Override
+                        public NBTTagCompound i(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Nullable
+                        @Override
+                        public NBTTagCompound j(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Override
+                        public Stream<net.minecraft.server.BlockPosition> m() {
+                            return null;
+                        }
+
+                        @Override
+                        public TickList<Block> n() {
+                            return null;
+                        }
+
+                        @Override
+                        public TickList<FluidType> o() {
+                            return null;
+                        }
+
+                        @Override
+                        public ChunkConverter p() {
+                            return null;
+                        }
+
+                        @Override
+                        public void setInhabitedTime(long i) {
+
+                        }
+
+                        @Override
+                        public long getInhabitedTime() {
+                            return 0;
+                        }
+
+                        @Override
+                        public boolean r() {
+                            return false;
+                        }
+
+                        @Override
+                        public void b(boolean flag) {
+
+                        }
+
+                        @Nullable
+                        @Override
+                        public TileEntity getTileEntity(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Override
+                        public IBlockData getType(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Override
+                        public IBlockData getTypeIfLoaded(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Override
+                        public Fluid getFluidIfLoaded(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Override
+                        public Fluid getFluid(net.minecraft.server.BlockPosition blockposition) {
+                            return null;
+                        }
+
+                        @Nullable
+                        @Override
+                        public StructureStart<?> a(StructureGenerator<?> structureGenerator) {
+                            return null;
+                        }
+
+                        @Override
+                        public void a(StructureGenerator<?> structureGenerator, StructureStart<?> structureStart) {
+
+                        }
+
+                        @Override
+                        public LongSet b(StructureGenerator<?> structureGenerator) {
+                            return null;
+                        }
+
+                        @Override
+                        public void a(StructureGenerator<?> structureGenerator, long l) {
+
+                        }
+
+                        @Override
+                        public Map<StructureGenerator<?>, LongSet> v() {
+                            return null;
+                        }
+
+                        @Override
+                        public void b(Map<StructureGenerator<?>, LongSet> map) {
+
+                        }
+                    });
+                } else throw new IllegalArgumentException();
+            }
+            final String name = method.getName();
+            try {
+                method.invoke(impl, parameters);
+            } catch (InvocationTargetException e) {
+                if(!(e.getTargetException() instanceof TestingLightEngineImpl.InvocationResult)) throw e;
+                Assert.assertEquals(((TestingLightEngineImpl.InvocationResult)e.getTargetException()).invokedMethod, name);
+                Assert.assertArrayEquals(((TestingLightEngineImpl.InvocationResult)e.getTargetException()).invokedObjects, parameters);
+            }
+        }
+    }
+
+    private byte[] generateNibble() {
+        final byte[] bytes = new byte[2048];
+        Random random = new Random();
+        random.nextBytes(bytes);
+        return bytes;
+    }
+
+}
diff --git a/src/test/java/net/yatopia/server/hwaccel/structure/TestingLightEngineImpl.java b/src/test/java/net/yatopia/server/hwaccel/structure/TestingLightEngineImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..d603c78ac75bf7ce40674db6f74ceeea79a84445
--- /dev/null
+++ b/src/test/java/net/yatopia/server/hwaccel/structure/TestingLightEngineImpl.java
@@ -0,0 +1,87 @@
+package net.yatopia.server.hwaccel.structure;
+
+import net.yatopia.lighting.api.LightEngineImpl;
+import net.yatopia.lighting.api.structures.BlockPosition;
+import net.yatopia.lighting.api.structures.Chunk;
+import net.yatopia.lighting.api.structures.ChunkPosition;
+import net.yatopia.lighting.api.structures.ChunkSectionPosition;
+import net.yatopia.lighting.api.structures.LightAccessor;
+import net.yatopia.lighting.api.structures.LightType;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletableFuture;
+
+public class TestingLightEngineImpl implements LightEngineImpl {
+
+    @Override
+    public int doLightUpdates(int maxUpdateCount, boolean doSkylight, boolean skipEdgeLightPropagation) {
+        throw new InvocationResult("doLightUpdates", maxUpdateCount, doSkylight, skipEdgeLightPropagation);
+    }
+
+    @Override
+    public void addLightSource(BlockPosition pos, int level) {
+        throw new InvocationResult("addLightSource", pos, level);
+    }
+
+    @Override
+    public void checkBlock(BlockPosition pos) {
+        throw new InvocationResult("checkBlock", pos);
+    }
+
+    @Override
+    public void updateChunkStatus(ChunkPosition pos) {
+        throw new InvocationResult("updateChunkStatus", pos);
+    }
+
+    @Override
+    public void setSectionStatus(ChunkSectionPosition pos, boolean notReady) {
+        throw new InvocationResult("setSectionStatus", pos, notReady);
+    }
+
+    @Override
+    public void setColumnEnabled(ChunkPosition pos, boolean lightEnabled) {
+        throw new InvocationResult("setColumnEnabled", pos, lightEnabled);
+    }
+
+    @Override
+    public void enqueueSectionData(LightType lightType, ChunkSectionPosition pos, @Nullable byte[] nibbles, boolean flag) {
+        throw new InvocationResult("enqueueSectionData", lightType, pos, nibbles, flag);
+    }
+
+    @Override
+    public void setRetainData(ChunkPosition pos, boolean retainData) {
+        throw new InvocationResult("setRetainData", pos, retainData);
+    }
+
+    @Override
+    public CompletableFuture<Void> lightChunk(Chunk chunk, boolean excludeBlocks) {
+        throw new InvocationResult("lightChunk", chunk, excludeBlocks);
+    }
+
+    @Override
+    public LightAccessor get(LightType lightType) {
+        throw new InvocationResult("get", lightType);
+    }
+
+    @Override
+    public int getLight(BlockPosition pos, int ambientDarkness) {
+        throw new InvocationResult("getLight", pos, ambientDarkness);
+    }
+
+    @Override
+    public void close() {
+        throw new InvocationResult("close");
+    }
+
+    public static class InvocationResult extends RuntimeException {
+
+        public final String invokedMethod;
+        public final Object[] invokedObjects;
+
+        public InvocationResult(String invokedMethod, Object... invokedObjects) {
+            this.invokedMethod = invokedMethod;
+            this.invokedObjects = invokedObjects;
+        }
+    }
+
+}
